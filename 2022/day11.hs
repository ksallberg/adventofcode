{-# LANGUAGE TemplateHaskell #-}

module Day11 where

import Control.Monad
import Control.Lens
import Data.List
import Data.Maybe

-- code here is generated by ChatGPT, then modified by me to compile and work

data Monkey = Monkey
  { _mid :: Int
  , _items :: [Integer]
  , _operation :: Integer -> Integer
  , _test :: Integer -> Int
  , _inspects :: Integer
  }

$(makeLenses ''Monkey)

-- fulhack :: Int
-- fulhack = 7*17*11*13*19*2*5*3
fulhack = 23*19*13*17

-- Create a monkey with the given starting items,
-- operation, test, and throwTo value
mkMonkey :: Int -> [Integer] -> (Integer -> Integer) ->
  (Integer, Int, Int) -> Monkey
mkMonkey id items op cond = Monkey id items op (mkTest cond) 0

mkTest :: (Integer, Int, Int) -> (Integer -> Int)
mkTest (divby,monkeya,monkeyb) =
  (\input ->
     case input `mod` divby of
       0 ->
         monkeya
       _ ->
         monkeyb)

-- Create a list of monkeys using the mkMonkey function
-- monkeys =
--   [ mkMonkey 0 [89, 84, 88, 78, 70] (* 5) (7, 6, 7)
--   , mkMonkey 1 [76, 62, 61, 54, 69, 60, 85] (+ 1) (17, 0, 6)
--   , mkMonkey 2 [83, 89, 53] (+ 8) (11, 5, 3)
--   , mkMonkey 3 [95, 94, 85, 57] (+ 4) (13, 0, 1)
--   , mkMonkey 4 [82, 98] (+ 7) (19, 5, 2)
--   , mkMonkey 5 [69] (+ 2) (2, 1, 3)
--   , mkMonkey 6 [82, 70, 58, 87, 59, 99, 92, 65] (* 11) (5, 7, 4)
--   , mkMonkey 7 [91, 53, 96, 98, 68, 82] (^ 2) (3, 4, 2)
--   ]
monkeys =
    [ mkMonkey 0 [79, 98] (* 19) (23, 2, 3),
      mkMonkey 1 [54, 65, 75, 74] (+6) (19, 2, 0),
      mkMonkey 2 [79, 60, 97] (^2) (13, 1, 3),
      mkMonkey 3 [74] (+3) (17, 0, 1)
    ]
-- rest is not by ChatGPT:

main :: IO ()
main =
  let ms1 = foldl (\ms _ -> mround 0 (length monkeys) ms) monkeys [0..9999]
      [a, b] = take 2 ((reverse . sort) [x ^. inspects|x <- ms1])
  in putStrLn $ "res" ++ (show (a*b))

mround :: Int -> Int -> [Monkey] -> [Monkey]
mround num goal ms | num == goal = ms
                   | otherwise =
  let (newMonkey, throwToItems) = inspect (ms !! num)
  in mround (num+1) goal (foldl mround' (updMonkey newMonkey ms) throwToItems)

mround' :: [Monkey] -> (Int, Integer) -> [Monkey]
mround' acc (whichMonkey, item) =
  updMonkey (appendItem (acc !! whichMonkey) item) acc

appendItem :: Monkey -> Integer -> Monkey
appendItem m item = m & items .~ (m ^. items) ++ [item]

updMonkey :: Monkey -> [Monkey] -> [Monkey]
updMonkey m ms = ms & ix (m ^. mid) .~ m

inspect :: Monkey -> (Monkey, [(Int, Integer)])
inspect m = let numItems = (toInteger . length) (m ^. items)
                updF = (\x-> (m ^. operation) x `mod` fulhack)
                newM = m & items .~ fmap updF (m ^. items)
                newM2 = newM & inspects .~ (m ^. inspects) + numItems
                throwToItems = fmap (\x->((m ^. test) x, x)) (newM2 ^. items)
            in (newM2 & items .~ [], throwToItems)
